#version 430 core

// might be faster to make this more than one but honestly i do not care at the moment
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform int resolution;
uniform ivec3 cells_per_axis;

// generated on the cpu and loaded here
layout(std430, binding = 0) readonly buffer point_ssbo {
    // NOTE(nix3l): always avoid using vec3s and mat3s in SSBOs
    // because they have to be aligned to a 16-byte boundary
    // which is the same size as a vec4. same applies to mat3s
    // so just to make it easier, always use vec4s and mat4s instead
    // note that we are wasting quite a bit of space here
    // but it wont really matter
    vec4 point_offset_data[];
};

layout(rgba32f, binding = 1) uniform writeonly image3D volume;

const ivec3[27] offsets = {
    ivec3(-1,  1, -1), ivec3(0,  1, -1), ivec3(1,  1, -1),
    ivec3(-1,  0, -1), ivec3(0,  0, -1), ivec3(1,  0, -1), // LAYER UNDER
    ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1),

    ivec3(-1,  1,  0), ivec3(0,  1,  0), ivec3(1,  1,  0),
    ivec3(-1,  0,  0), ivec3(0,  0,  0), ivec3(1,  0,  0), // LAYER IN LINE
    ivec3(-1, -1,  0), ivec3(0, -1,  0), ivec3(1, -1,  0),

    ivec3(-1,  1,  1), ivec3(0,  1,  1), ivec3(1,  1,  1),
    ivec3(-1,  0,  1), ivec3(0,  0,  1), ivec3(1,  0,  1), // LAYER ABOVE
    ivec3(-1, -1,  1), ivec3(0, -1,  1), ivec3(1, -1,  1),
};

float dist2(vec3 pos, vec3 point) {
    vec3 pp = point - pos;
    return dot(pp, pp);
}

uint flatten_index(ivec3 point_pos, int cpa) {
    return point_pos.x + cpa * (point_pos.y + cpa * point_pos.z);
}

vec3 point_at_index(vec3 group_id, ivec3 index, int cpa, int offset) {
    return group_id / float(cpa) + point_offset_data[flatten_index(index, cpa) + offset].xyz;
}

float enumerate_points(vec3 position, int cpa, int index_offset) {
    vec3 cell = floor(position * cpa);
    float min_dst = 1.0f;

    // loop through all adjacent cells and get the smallest distance
    // instead of looping through all points in the cube
    for(int i = 0; i < 27; i ++) {
        ivec3 offset = offsets[i];

        // wrap offset
        ivec3 cell_index = ivec3(cell);
        for(int c = 0; c < 3; c ++) {
            if(cell_index[c] == 0 && offset[c] == -1) offset[c] = cpa - 1;
            if(cell_index[c] == cpa - 1 && offset[c] == 1) offset[c] = 1 - cpa;
        }

        float dst = dist2(position, point_at_index(cell + offset, ivec3(cell) + offset, cpa, index_offset));
        min_dst = min(min_dst, dst);
    }

    return 1.0f - clamp(cpa * sqrt(min_dst), 0.0f, 1.0f);
}

void main(void) {
    vec3 normalised_position = vec3(gl_GlobalInvocationID) / float(resolution);
    
    int ld_points = int(pow(cells_per_axis.x, 3));
    int md_points = int(pow(cells_per_axis.y, 3));

    float ld_dst = enumerate_points(normalised_position, cells_per_axis.x, 0);
    float md_dst = enumerate_points(normalised_position, cells_per_axis.y, ld_points);
    float hd_dst = enumerate_points(normalised_position, cells_per_axis.z, ld_points + md_points);

    imageStore(volume, ivec3(gl_GlobalInvocationID), vec4(ld_dst, md_dst, hd_dst, 1.0));
}
