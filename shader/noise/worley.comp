#version 430 core

// might be faster to make this more than one but honestly i do not care at the moment
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// generated on the cpu and loaded here
layout(std430, binding = 0) readonly buffer point_ssbo {
    vec3 point_offset_data[];
};

layout(rgba32f, binding = 1) uniform writeonly image3D volume;

uniform float resolution;
uniform int cells_per_axis;

const ivec3[27] offsets = {
    ivec3(-1,  1, -1), ivec3(0,  1, -1), ivec3(1,  1, -1),
    ivec3(-1,  0, -1), ivec3(0,  0, -1), ivec3(1,  0, -1), // LAYER UNDER
    ivec3(-1, -1, -1), ivec3(0, -1, -1), ivec3(1, -1, -1),

    ivec3(-1,  1,  0), ivec3(0,  1,  0), ivec3(1,  1,  0),
    ivec3(-1,  0,  0), ivec3(0,  0,  0), ivec3(1,  0,  0), // LAYER IN LINE
    ivec3(-1, -1,  0), ivec3(0, -1,  0), ivec3(1, -1,  0),

    ivec3(-1,  1,  1), ivec3(0,  1,  1), ivec3(1,  1,  1),
    ivec3(-1,  0,  1), ivec3(0,  0,  1), ivec3(1,  0,  1), // LAYER ABOVE
    ivec3(-1, -1,  1), ivec3(0, -1,  1), ivec3(1, -1,  1),
};

float dist2(vec3 pos, vec3 point) {
    vec3 pp = point - pos;
    return dot(pp, pp);
}

uint flatten_index(ivec3 point_pos) {
    return point_pos.x + cells_per_axis * (point_pos.y + cells_per_axis * point_pos.z);
}

vec3 point_at_index(vec3 group_id, ivec3 index) {
    // this is the most hacky thing i have ever made holy
    // so for whatever reason the SSBO just straight up stops working
    // after exactly going 3/4ths of the way through the array of points????
    // huh????
    // so yeah i guess just ignore those for now and wrap around
    // i guess it works for now. could be an nvidia linux driver issue or whatever
    // but i dont care enough to look into it right now
    int p34 = cells_per_axis * cells_per_axis * cells_per_axis * 3 / 4;
    return group_id / float(cells_per_axis) + point_offset_data[(flatten_index(index) + p34) % p34];
}

float enumerate_points(vec3 position) {
    vec3 cell = floor(position * cells_per_axis);
    float min_dst = 1.0f;

    // loop through all adjacent cells and get the smallest distance
    // instead of looping through all points in the cube
    for(int i = 0; i < 27; i ++) {
        ivec3 offset = offsets[i];

        // wrap offset
        ivec3 cell_index = ivec3(cell);
        for(int c = 0; c < 3; c ++) {
            if(cell_index[c] == 0 && offset[c] == -1) offset[c] = cells_per_axis - 1;
            if(cell_index[c] == cells_per_axis - 1 && offset[c] == 1) offset[c] = 1 - cells_per_axis;
        }

        float dst = dist2(position, point_at_index(cell + offset, ivec3(cell) + offset));
        min_dst = min(min_dst, dst);
    }

    return 1.0f - clamp(cells_per_axis * sqrt(min_dst), 0.0f, 1.0f);
}

void main(void) {
    ivec3 position = ivec3(gl_GlobalInvocationID);
    float dst = enumerate_points(vec3(gl_GlobalInvocationID) / resolution);

    // imageStore(volume, position, vec4(point_offset_data[flatten_index(ivec3(floor(vec3(gl_GlobalInvocationID) / resolution * cells_per_axis)))], 1.0));
    // imageStore(volume, position, vec4(flatten_index(ivec3(floor(vec3(gl_GlobalInvocationID) / resolution * cells_per_axis)))));
    imageStore(volume, position, vec4(dst));
}
